写一下解题思路：
这个题n很大，10^9，所以不能打表。我们就要采用比较高效的方法。
如果我们来考虑每一个数，它一共有多少个1，这样想会很麻烦，我刚开始用排列与组合写了好久，发现到最高位的时候并不怎么好写。后来考虑另一种方法：
我们统计每个位置上可能出现1的数，这样就把问题拆开了。
比如：12。个位上可能出现1的数为1,11（一共2个），十位上可能出现1的个数为10，11，12（一共3个），加一起正好是5。（至于11是否重复的问题，还是再理解一下上面的做法，这个做法只考虑了每一位出现1的数，11在个位上算和在十位上算是不一样的，所以并没有重复）。

那么我们再看一个多位数21905：
个位：它出现1的数为：1 ~ 21901，一共 2190 - 0 + 1 = 2191
十位：它出现1的数为：1x ~ 2181x （x 从0到9）一共：（218 - 0 + 1）*10 = 2190
百位：它出现1的数为：1xx ~ 211xx ，一共：（21 - 0 + 1）* 100 = 2200
千位：它出现1的数为：1xxx ~ 11xxx 和 21000 ~ 21905 ，那么很明显，这个情况就比较特殊了，为什么呢？下面再说，我们先计数，一共：（1 - 0 + 1）*1000 + （905 - 0 + 1）= 2000 + 906 = 2906
万位：它出现1的数为：1xxxx ~ 1xxxx，一共：10000

那么我们求和：2191 + 2190 + 2200 + 2906 + 10000 = 19487



程序：
#include <stdio.h>

#include <cstring>

#include <cmath>

#include <algorithm>

using namespace std;

#define CLR(a,b) memset(a,b,sizeof(a))

#define INF 0x3f3f3f3f

#define LL long long

int main()

{

	int n;

	int t,tn;

	LL ans = 0;

	int mul = 1;

	scanf ("%d",&n);

	tn = n;

	while (tn)

	{

		t = tn % 10;

		if (t == 0)

			ans += n / (mul * 10) * mul;		//高位数字 

		else if (t == 1)

		{

			ans += n / (mul * 10) * mul;

			ans += (n % mul) + 1;

		}

		else		//只与高位有关 

			ans += (n / (mul * 10) + 1) * mul;

		mul *= 10;

		tn /= 10;

//		printf ("%lld\n",ans);

	}

	printf ("%lld\n",ans);

	return 0;

}
